[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/slicing/min_call.c (with preprocessing)
tests/slicing/select_return.c:45:[kernel] warning: Calling undeclared function f. Old style K&R code?
[value] Analyzing an incomplete application starting at g
[value] Computing initial state
[value] Initial state computed
[value] Values of globals at initialization
  G ∈ [--..--]
  H ∈ [--..--]
  I ∈ [--..--]
[value] computing for function k <- g.
        Called from tests/slicing/select_return.c:44.
[value] computing for function get <- k <- g.
        Called from tests/slicing/select_return.c:35.
tests/slicing/select_return.c:35:[kernel] warning: Neither code nor specification for function get, generating default assigns from the prototype
[value] using specification for function get
[value] Done for function get
[value] computing for function send_bis <- k <- g.
        Called from tests/slicing/select_return.c:39.
tests/slicing/select_return.c:39:[kernel] warning: Neither code nor specification for function send_bis, generating default assigns from the prototype
[value] using specification for function send_bis
[value] Done for function send_bis
[value] Recording results for k
[value] Done for function k
[value] computing for function f <- g.
        Called from tests/slicing/select_return.c:45.
[value] computing for function k <- f <- g.
        Called from tests/slicing/select_return.c:49.
[value] computing for function get <- k <- f <- g.
        Called from tests/slicing/select_return.c:35.
[value] Done for function get
[value] computing for function send_bis <- k <- f <- g.
        Called from tests/slicing/select_return.c:39.
[value] Done for function send_bis
[value] Recording results for k
[value] Done for function k
[value] computing for function k <- f <- g.
        Called from tests/slicing/select_return.c:50.
[value] computing for function get <- k <- f <- g.
        Called from tests/slicing/select_return.c:35.
[value] Done for function get
[value] computing for function send_bis <- k <- f <- g.
        Called from tests/slicing/select_return.c:39.
[value] Done for function send_bis
[value] Recording results for k
[value] Done for function k
[value] computing for function k <- f <- g.
        Called from tests/slicing/select_return.c:51.
[value] computing for function get <- k <- f <- g.
        Called from tests/slicing/select_return.c:35.
[value] Done for function get
[value] computing for function send_bis <- k <- f <- g.
        Called from tests/slicing/select_return.c:39.
[value] Done for function send_bis
[value] Recording results for k
[value] Done for function k
[value] computing for function send <- f <- g.
        Called from tests/slicing/select_return.c:53.
tests/slicing/select_return.c:53:[kernel] warning: Neither code nor specification for function send, generating default assigns from the prototype
[value] using specification for function send
[value] Done for function send
[value] Recording results for f
[value] Done for function f
[value] Recording results for g
[value] done for function g
[from] Computing for function k
[from] Computing for function get <-k
[from] Done for function get
[from] Computing for function send_bis <-k
[from] Done for function send_bis
[from] Done for function k
[from] Computing for function f
[from] Computing for function send <-f
[from] Done for function send
[from] Done for function f
[from] Computing for function g
[from] Done for function g
[from] ====== DEPENDENCIES COMPUTED ======
       These dependencies hold at termination for the executions that terminate:
[from] Function get:
  \result FROM y
[from] Function send:
  NO EFFECTS
[from] Function send_bis:
  NO EFFECTS
[from] Function k:
  G FROM b
  H FROM c
  \result FROM a
[from] Function f:
  G FROM \nothing
  H FROM \nothing
  \result FROM y
[from] Function g:
  G FROM \nothing
  H FROM \nothing
[from] ====== END OF DEPENDENCIES ======
[slicing] making slicing project 'slicing_1'...
[pdg] computing for function k
[pdg] done for function k
[slicing] applying all slicing requests...
[slicing] applying 1 actions...
[slicing] applying actions: 1/1...
[pdg] computing for function f
[pdg] done for function f
[pdg] computing for function g
[pdg] done for function g
Project1 - result1 :
[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
extern int get(int y);

/*@ assigns \nothing; */
extern void send_bis(int x);

void k_slice_1(int d)
{
  int cond;
  cond = get(d);
  if (cond) send_bis(d);
  return;
}

void f_slice_1(void);

void g(void)
{
  k_slice_1(0);
  f_slice_1();
  return;
}

void f_slice_1(void)
{
  k_slice_1(0);
  k_slice_1(0);
  k_slice_1(0);
  return;
}


Project1 - result2 :
int G;
int H;
int I;
/*@ assigns \result;
    assigns \result \from y; */
extern int get(int y);

/*@ assigns \nothing; */
extern void send(int x);

/*@ assigns \nothing; */
extern void send_bis(int x);

Print slice = k_slice_2: (InCtrl: <[ S ], [---]>)
                         (In4: <[--d], [---]>)

/**/int k(/* <[---], [---]> */ int a, /* <[---], [---]> */ int b,
          /* <[---], [---]> */ int c, /* <[--d], [---]> */ int d)
{
  /* <[ S ], [---]> */ int cond;
  /* sig call:
    (InCtrl: <[ S ], [---]>)
    (In1: <[ S ], [---]>)
    (OutRet: <[ S ], [---]>) */
  /* undetermined call */
  /* <[ S ], [---]> */
  cond = get(d);
  /* <[---], [---]> */
  G = b;
  /* <[---], [---]> */
  H = c;
  /* <[ S ], [---]> */
  if (cond) {
    /* sig call: (InCtrl: <[ S ], [---]>)
                 (In1: <[ S ], [---]>) */
    /* undetermined call */
    /* <[ S ], [---]> */
    send_bis(d);
  }
  /* <[---], [---]> */
  return a;
}

Print slice = k_slice_1: (InCtrl: <[ S ], [ S ]>)
                         (In4: <[--d], [ S ]>)

/**/int k(/* <[---], [---]> */ int a, /* <[---], [---]> */ int b,
          /* <[---], [---]> */ int c, /* <[--d], [ S ]> */ int d)
{
  /* <[ S ], [ S ]> */ int cond;
  /* sig call:
    (InCtrl: <[ S ], [ S ]>)
    (In1: <[ S ], [ S ]>)
    (OutRet: <[ S ], [ S ]>) */
  /* call to source function */
  /* <[ S ], [ S ]> */
  cond = get(d);
  /* <[---], [---]> */
  G = b;
  /* <[---], [---]> */
  H = c;
  /* <[ S ], [ S ]> */
  if (cond) {
    /* sig call: (InCtrl: <[ S ], [ S ]>)
                 (In1: <[ S ], [ S ]>) */
    /* call to source function */
    /* <[ S ], [ S ]> */
    send_bis(d);
  }
  /* <[---], [---]> */
  return a;
}

int f(int y);

Print slice = g_slice_1: (InCtrl: <[--d], [ S ]>)

/**/void g(/* <[---], [---]> */ int b, /* <[---], [---]> */ int c)
{
  /* <[---], [---]> */ int r;
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[ S ], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  r = k(0,0,c,0);
  /* sig call: (InCtrl: <[--d], [ S ]>) */
  /* call to f_slice_1: (InCtrl: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  f(b);
  /* <[---], [---]> */
  return;
}

Print slice = f_slice_1: (InCtrl: <[--d], [ S ]>)

/**/int f(/* <[---], [---]> */ int y)
{
  /* <[---], [---]> */ int r;
  /* <[---], [---]> */ int z;
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[ S ], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  k(0,0,0,0);
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[ S ], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  r = k(0,y,0,0);
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[ S ], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  z = k(G,0,0,0);
  /*@ slice pragma expr z; */ /* <[---], [---]> */
                              ;
  /* invisible call */ /* <[---], [---]> */
  send(z);
  /* <[---], [---]> */
  return z;
}

Slicing project worklist [default/slicing_1] =
[k_slice_2 = choose_call for call 6][k_slice_2 = choose_call for call 1]

[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 2 actions...
[slicing] applying actions: 1/2...
[slicing] applying actions: 2/2...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
extern int get(int y);

/*@ assigns \nothing; */
extern void send_bis(int x);

void k_slice_2(int d)
{
  int cond;
  cond = get(d);
  if (cond) send_bis(d);
  return;
}

void k_slice_1(int d)
{
  int cond;
  cond = get(d);
  if (cond) send_bis(d);
  return;
}

void f_slice_1(void);

void g(void)
{
  k_slice_1(0);
  f_slice_1();
  return;
}

void f_slice_1(void)
{
  k_slice_1(0);
  k_slice_1(0);
  k_slice_1(0);
  return;
}


[slicing] making slicing project 'slicing_2'...
Slicing project worklist [default/slicing_2] =
[k = (n:17 ,<[--d], [---]>)]

[slicing] applying all slicing requests...
[slicing] applying 1 actions...
[slicing] applying actions: 1/1...
Project3 - result :
int G;
int H;
int I;
/*@ assigns \result;
    assigns \result \from y; */
extern int get(int y);

/*@ assigns \nothing; */
extern void send(int x);

/*@ assigns \nothing; */
extern void send_bis(int x);

Print slice = k_slice_1: (InCtrl: <[--d], [ S ]>)
                         (In4: <[--d], [ S ]>)

/**/int k(/* <[---], [---]> */ int a, /* <[---], [---]> */ int b,
          /* <[---], [---]> */ int c, /* <[--d], [ S ]> */ int d)
{
  /* <[--d], [ S ]> */ int cond;
  /* sig call:
    (InCtrl: <[--d], [ S ]>)
    (In1: <[--d], [ S ]>)
    (OutRet: <[--d], [ S ]>) */
  /* call to source function */
  /* <[--d], [ S ]> */
  cond = get(d);
  /* <[---], [---]> */
  G = b;
  /* <[---], [---]> */
  H = c;
  /* <[--d], [ S ]> */
  if (cond) {
    /* sig call: (InCtrl: <[--d], [ S ]>)
                 (In1: <[---], [ S ]>) */
    /* call to source function */
    /* <[--d], [ S ]> */
    send_bis(d);
  }
  /* <[---], [---]> */
  return a;
}

int f(int y);

Print slice = g_slice_1: (InCtrl: <[--d], [ S ]>)

/**/void g(/* <[---], [---]> */ int b, /* <[---], [---]> */ int c)
{
  /* <[---], [---]> */ int r;
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[--d], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  r = k(0,0,c,0);
  /* sig call: (InCtrl: <[--d], [ S ]>) */
  /* call to f_slice_1: (InCtrl: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  f(b);
  /* <[---], [---]> */
  return;
}

Print slice = f_slice_1: (InCtrl: <[--d], [ S ]>)

/**/int f(/* <[---], [---]> */ int y)
{
  /* <[---], [---]> */ int r;
  /* <[---], [---]> */ int z;
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[--d], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  k(0,0,0,0);
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[--d], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  r = k(0,y,0,0);
  /* sig call: (InCtrl: <[--d], [ S ]>)
               (In4: <[--d], [ S ]>) */
  /* call to k_slice_1: (InCtrl: <[--d], [ S ]>)
                        (In4: <[--d], [ S ]>) */
  /* <[--d], [ S ]> */
  z = k(G,0,0,0);
  /*@ slice pragma expr z; */ /* <[---], [---]> */
                              ;
  /* invisible call */ /* <[---], [---]> */
  send(z);
  /* <[---], [---]> */
  return z;
}

Slicing project worklist [default/slicing_2] =


[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
extern int get(int y);

/*@ assigns \nothing; */
extern void send_bis(int x);

void k_slice_1(int d)
{
  int cond;
  cond = get(d);
  if (cond) send_bis(d);
  return;
}

void f_slice_1(void);

void g(void)
{
  k_slice_1(0);
  f_slice_1();
  return;
}

void f_slice_1(void)
{
  k_slice_1(0);
  k_slice_1(0);
  k_slice_1(0);
  return;
}


[slicing] making slicing project 'slicing_3'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
Slicing project worklist [default/slicing_3] =
[f = (n:26 ,<[acd], [---]>)(n:33 ,<[acd], [---]>)(n:41 ,<[acd], [---]>)][g = (n:60 ,
<[acd],
[---]>)]

Slicing project worklist [default/slicing_3] =
[f_slice_1 = choose_call for call 17][f_slice_1 = choose_call for call 16][f_slice_1 = choose_call for call 15][g = propagate (n:68 ,
<[acd],
[---]>)][Appli : calls to f][g = (n:60 ,<[acd], [---]>)]

[slicing] applying all slicing requests...
[slicing] applying 6 actions...
[slicing] applying actions: 1/6...
[slicing] applying actions: 2/6...
[slicing] applying actions: 3/6...
[slicing] applying actions: 4/6...
[slicing] applying actions: 5/6...
[slicing] applying actions: 6/6...
Project3 - result :
int G;
int H;
int I;
/*@ assigns \result;
    assigns \result \from y; */
extern int get(int y);

/*@ assigns \nothing; */
extern void send(int x);

/*@ assigns \nothing; */
extern void send_bis(int x);

Print slice = k_slice_1: 

/**/int k(/* <[---], [---]> */ int a, /* <[---], [---]> */ int b,
          /* <[---], [---]> */ int c, /* <[---], [---]> */ int d)
{
  /* <[---], [---]> */ int cond;
  /* invisible call */ /* <[---], [---]> */
  cond = get(d);
  /* <[---], [---]> */
  G = b;
  /* <[---], [---]> */
  H = c;
  /* <[---], [---]> */
  if (cond) {
    /* invisible call */ /* <[---], [---]> */
    send_bis(d);
  }
  /* <[---], [---]> */
  return a;
}

int f(int y);

Print slice = g_slice_1: (InCtrl: <[acd], [---]>)

/**/void g(/* <[---], [---]> */ int b, /* <[---], [---]> */ int c)
{
  /* <[---], [---]> */ int r;
  /* sig call: (InCtrl: <[acd], [---]>) */
  /* call to k_slice_1:  */
  /* <[acd], [---]> */
  r = k(0,0,c,0);
  /* sig call: (InCtrl: <[acd], [---]>) */
  /* call to f_slice_1: (InCtrl: <[acd], [---]>) */
  /* <[acd], [---]> */
  f(b);
  /* <[---], [---]> */
  return;
}

Print slice = f_slice_1: (InCtrl: <[acd], [---]>)

/**/int f(/* <[---], [---]> */ int y)
{
  /* <[---], [---]> */ int r;
  /* <[---], [---]> */ int z;
  /* sig call: (InCtrl: <[acd], [---]>) */
  /* call to k_slice_1:  */
  /* <[acd], [---]> */
  k(0,0,0,0);
  /* sig call: (InCtrl: <[acd], [---]>) */
  /* call to k_slice_1:  */
  /* <[acd], [---]> */
  r = k(0,y,0,0);
  /* sig call: (InCtrl: <[acd], [---]>) */
  /* call to k_slice_1:  */
  /* <[acd], [---]> */
  z = k(G,0,0,0);
  /*@ slice pragma expr z; */ /* <[---], [---]> */
                              ;
  /* invisible call */ /* <[---], [---]> */
  send(z);
  /* <[---], [---]> */
  return z;
}

Slicing project worklist [default/slicing_3] =


[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
void k_slice_1(void)
{
  return;
}

void f_slice_1(void);

void g(void)
{
  k_slice_1();
  f_slice_1();
  return;
}

void f_slice_1(void)
{
  k_slice_1();
  k_slice_1();
  k_slice_1();
  return;
}


